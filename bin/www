#!/usr/bin/env node
/* eslint linebreak-style: ["error", "unix"]*/
/**
 * Module dependencies.
 */
const app = require('../app'); // app is instance of Express
const debug = require('debug')('dz-listing:server');
const http = require('http');
/**
 * Get port from environment and store in Express.
 */
const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */
const server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */
server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

const io = require('socket.io')(server);
app.set('socketio', io);


/**
 * Normalize a port into a number, string, or false.
 * @param {Number} val
 * @return {Boolean}
 */
function normalizePort(val) {
  const port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 * @param {Error} error
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof port === 'string' ?
    'Pipe ' + port :
    'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  const addr = server.address();
  const bind = typeof addr === 'string' ?
    'pipe ' + addr :
    'port ' + addr.port;
  debug('Listening on ' + bind);
}

const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  defaultMeta: {service: 'user-service'},
  transports: [
    //
    // - Write all logs with level `error` and below to `error.log`
    // - Write all logs with level `info` and below to `combined.log`
    //
    new winston.transports.File({filename: 'error.log', level: 'error'}),
    new winston.transports.File({filename: 'combined.log'}),
  ],
});

//
// If we're not in production then log to the `console` with the format:
// `${info.level}: ${info.message} JSON.stringify({ ...rest }) `
//
if (process.env.NODE_ENV !== 'prod') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}


const gracefulShutdown = require('http-graceful-shutdown');

/**
 * shutdownFunction
 * @param {Number} signal
 * @return {Promise}
 */
function shutdownFunction(signal) {
  return new Promise((resolve) => {
    console.log('... called signal: ' + signal);
    console.log('... in cleanup');
    setTimeout(function() {
      console.log('... cleanup finished');
      resolve();
    }, 1000);
  });
}

/**
 * cleanup
 */
function finalFunction() {
  console.log('Server gracefulls shutted down.....');
}

gracefulShutdown(server,
    {
      signals: 'SIGINT SIGTERM',
      timeout: 10000, // timeout: 10 secs
      development: false, // not in dev mode
      forceExit: true, // triggers process.exit() at the end of shutdown process
      // needed operation before httpConnections are shutted down
      // preShutdown: preShutdownFunction,
      onShutdown: shutdownFunction, // shutdown function (async) -  for cleanup DB, ...
      finally: finalFunction, // finally function (sync) - e.g. for logging
    },
);

const fs = require('fs');
const path = require('path');
const filePath = path.join(__dirname, '../restartLevel.txt');
let restartLevel = -1;
fs.readFile(filePath, {encoding: 'utf-8'}, function(err, data) {
  if (!err) {
    restartLevel = parseInt(data);
    console.log(restartLevel);
  } else {
    console.log(err);
  }
});

process.on('uncaughtException', function(err) {
  // handle the error safely
  console.log(err);
  process.exit(1);
});

// the asynchronous or synchronous code that emits the otherwise uncaught error
// const err = new Error('example');
// throw err;
